#pragma once

#include "Config.hpp"
#include "MikrotikNote.hpp"
#include "Utils.hpp"

#include "boost/log/trivial.hpp"

#include <fstream>
#include <iomanip>
#include <sstream>
#include <vector>

class TrackMetaTextInfo
{
public:
    std::string text;
    std::string copyright;
    std::string track;
    std::string instrument;
    std::string lyric;
    std::string marker;
    std::string cue;
};

static std::string getTrackTimeLength(const double time)
{
    std::stringstream out;
    out << Utils::getTimeAsText(time);
    out << " HH:MM:SS:MS";
    return out.str();
}

class MikrotikTrack
{
public:
    MikrotikTrack(Config &config, const std::size_t midiChannel) : m_config(config), m_midiChannel(midiChannel)
    {
    }

    void append(const MikrotikNote &note)
    {
        m_notes.push_back(note);
    }

    void setFileName(const std::string name)
    {
        m_outFileName = name;
    }

    void setTrackInfo(TrackMetaTextInfo &info)
    {
        m_metaTextInfo = info;
    }

    float duration() const
    {
        float duration = 0.0f;
        std::for_each(m_notes.begin(), m_notes.end(), [&](const MikrotikNote &note) {
            duration += note.preDelay();
            duration += note.duration();
        });
        return duration;
    }

    void noteComment(const MikrotikNote &note, std::ofstream &out)
    {
        out << " # " << std::string(pitch_to_name(m_config.pitchShift.process(note.pitch())));
        if (m_config.pitchShift.fine != 0.0f)
        {
            out << std::string(" ");
            out << ((m_config.pitchShift.fine < 0.0f) ? "-" : "+");
            out << m_config.pitchShift.fine;
            out << std::string(" Hz");
        }
        out << " @ " << Utils::getTimeAsText(m_timeElapsed);
    }

    void getScriptHeader(std::ofstream &out)
    {
        out << "#----------------File Description-----------------#\n";
        out << "# This file generated by Midi To Mikrotik Converter\n";
        out << "# Visit app repo: https://github.com/altucor/midi_to_mikrotik_converter\n";
        out << "# Pitch shift config: ";
        m_config.pitchShift.toStream(out);
        out << "\n";
        out << "# Original midi file name/path: " << m_config.inFileName << "\n";
        out << "# Track BPM: " << std::to_string(m_config.bpm) << "\n";
        out << "# MIDI Channel: " << std::to_string(m_midiChannel) << "\n";
        out << "# Number of notes: " << m_notes.size() << "\n";
        out << "# Track length: " << getTrackTimeLength(duration()) << "\n";
        out << "# Track name: " << m_metaTextInfo.track << "\n";
        out << "# Instrument name: " << m_metaTextInfo.instrument << "\n";
        out << "# Track text: " << m_metaTextInfo.text << "\n";
        out << "# Track copyright: " << m_metaTextInfo.copyright << "\n";
        out << "# Vocals: " << m_metaTextInfo.lyric << "\n";
        out << "# Text marker: " << m_metaTextInfo.marker << "\n";
        out << "# Cue Point: " << m_metaTextInfo.cue << "\n";
        out << "#-------------------------------------------------#\n\n";
    }

    int exportScript()
    {
        if (m_notes.size() == 0)
        {
            return 0;
        }

        std::ofstream outputFile;
        outputFile.open(m_outFileName);
        if (!outputFile.is_open())
        {
            BOOST_LOG_TRIVIAL(info) << "[MikrotikTrack] export failed cannot create output file: " << m_outFileName;
            return -1;
        }

        BOOST_LOG_TRIVIAL(info) << "[MikrotikTrack] export started for track: " << m_outFileName;
        getScriptHeader(outputFile);

        std::for_each(m_notes.begin(), m_notes.end(), [&](MikrotikNote &note) {
            if (note.preDelay() != 0)
            {
                m_timeElapsed += note.preDelay();
                outputFile << note.preDelayLine();
            }
            outputFile << note.beepLine(m_config.pitchShift);
            if (m_config.comments)
            {
                noteComment(note, outputFile);
            }
            outputFile << "\n";
            outputFile << note.delayLine();
            outputFile << "\n";
            m_timeElapsed += note.duration();
        });

        BOOST_LOG_TRIVIAL(info) << "[MikrotikTrack] export finished";
        return 0;
    }

private:
    Config m_config;
    std::size_t m_midiChannel = 0;
    std::string m_outFileName = "";
    TrackMetaTextInfo m_metaTextInfo;
    std::vector<MikrotikNote> m_notes;
    std::size_t m_timeElapsed = 0;
};
