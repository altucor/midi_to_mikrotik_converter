#pragma once

#include "Config.hpp"
#include "MikrotikNote.hpp"
#include "Utils.hpp"

#include "boost/log/trivial.hpp"

#include <fstream>
#include <iomanip>
#include <sstream>
#include <vector>

class TrackMetaTextInfo
{
public:
    std::string text;
    std::string copyright;
    std::string track;
    std::string instrument;
    std::string lyric;
    std::string marker;
    std::string cue;
};

static std::string getTrackTimeLength(const double time)
{
    std::stringstream out;
    out << Utils::getTimeAsText(time);
    out << " HH:MM:SS:MS";
    return out.str();
}

class MikrotikTrack
{
public:
    MikrotikTrack()
    {
    }

    MikrotikTrack(const std::size_t trackIndex, const std::size_t midiChannel, const std::size_t sequenceIndex)
        : m_trackIndex(trackIndex), m_midiChannel(midiChannel), m_sequenceIndex(sequenceIndex)
    {
        std::stringstream ss;
        ss << std::to_string(m_trackIndex);
        ss << "-" << std::to_string(m_midiChannel);
        ss << "-" << std::to_string(m_sequenceIndex);
        m_nameSuffix = ss.str();
    }

    const std::string prefix() const
    {
        return "[MikrotikTrack # " + m_nameSuffix + "] ";
    }

    bool tryAppend(const MikrotikNote &note)
    {
        if (!m_notes.size() || !note.intersectsWith(m_notes.back()))
        {
            m_notes.push_back(note);
            return true;
        }

        return false;
    }

    void setTrackInfo(TrackMetaTextInfo &info)
    {
        m_metaTextInfo = info;
    }

    float duration(const float pps) const
    {
        return duration_to_ms(m_notes.back().end(), pps);
    }

    void noteComment(const MikrotikNote &note, PitchShift pitchShift, const float timeElapsed, std::ofstream &out)
    {
        out << " # " << std::string(pitch_to_name(pitchShift.process(note.pitch())));
        if (pitchShift.fine != 0.0f)
        {
            out << std::string(" ");
            out << ((pitchShift.fine < 0.0f) ? "-" : "+");
            out << pitchShift.fine;
            out << std::string(" Hz");
        }
        out << " @ " << Utils::getTimeAsText(timeElapsed);
    }

    void getScriptHeader(const Config &config, const float pps, std::ofstream &out)
    {
        out << "#----------------File Description-----------------#\n";
        out << "# This file generated by Midi To Mikrotik Converter\n";
        out << "# Visit app repo: https://github.com/altucor/midi_to_mikrotik_converter\n";
        out << "# Pitch shift config: ";
        config.pitchShift.toStream(out);
        out << "\n";
        out << "# Original midi file name/path: " << config.inFileName << "\n";
        out << "# Track BPM: " << std::to_string(config.bpm) << "\n";
        out << "# MIDI Channel: " << std::to_string(m_midiChannel) << "\n";
        out << "# Number of notes: " << m_notes.size() << "\n";
        out << "# Track length: " << getTrackTimeLength(duration(pps)) << "\n";
        out << "# Track name: " << m_metaTextInfo.track << "\n";
        out << "# Instrument name: " << m_metaTextInfo.instrument << "\n";
        out << "# Track text: " << m_metaTextInfo.text << "\n";
        out << "# Track copyright: " << m_metaTextInfo.copyright << "\n";
        out << "# Vocals: " << m_metaTextInfo.lyric << "\n";
        out << "# Text marker: " << m_metaTextInfo.marker << "\n";
        out << "# Cue Point: " << m_metaTextInfo.cue << "\n";
        out << "#-------------------------------------------------#\n\n";
    }

    int exportScript(Config &config)
    {
        if (m_notes.size() == 0)
        {
            return 0;
        }

        std::string outFileName = config.inFileName + "-" + m_nameSuffix + ".txt";
        std::ofstream outputFile;

        outputFile.open(outFileName);
        if (!outputFile.is_open())
        {
            BOOST_LOG_TRIVIAL(fatal) << prefix() << "export failed cannot create output file: " << outFileName;
            return -1;
        }

        BOOST_LOG_TRIVIAL(info) << prefix() << "export started for track: " << outFileName;

        const float pps = pulses_per_second(config.ppqn, config.bpm);
        BOOST_LOG_TRIVIAL(debug) << prefix() << "pps: " << pps;
        getScriptHeader(config, pps, outputFile);

        std::size_t timeElapsed = 0;
        std::for_each(m_notes.begin(), m_notes.end(), [&](const MikrotikNote &note) {
            if (note.start() - timeElapsed)
            {
                // write predelay line if start timing is non zero
                outputFile << Utils::getDelayLine(duration_to_ms(note.start() - timeElapsed, pps));
            }
            outputFile << note.beepLine(config.pitchShift, pps);
            timeElapsed = note.start(); // update global comment timer
            if (config.comments)
            {
                noteComment(note, config.pitchShift, duration_to_ms(timeElapsed, pps), outputFile);
            }
            outputFile << "\n";
            outputFile << Utils::getDelayLine(duration_to_ms(note.duration(), pps));
            outputFile << "\n";
            timeElapsed = note.end();
        });

        BOOST_LOG_TRIVIAL(info) << prefix() << "export finished";
        return 0;
    }

private:
    std::string m_nameSuffix = "";
    std::size_t m_trackIndex = 0;
    std::size_t m_sequenceIndex = 0;
    std::size_t m_midiChannel = 0;
    TrackMetaTextInfo m_metaTextInfo;
    std::vector<MikrotikNote> m_notes;
};
