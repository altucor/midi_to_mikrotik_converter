#include "Mikrotik.hpp"

#include "util.h"
#include "boost/log/trivial.hpp"

#include <sstream>
#include <fstream>
#include <iomanip>

Mikrotik::Mikrotik(mtrk_t *track,
				   const uint16_t ppqn,
				   const int32_t bpm,
				   const uint64_t index,
				   const int octaveShift,
				   const int noteShift,
				   const double fineTuning,
				   const bool commentsFlag)
	: m_track(track),
	  m_ppqn(ppqn),
	  m_bpm(bpm),
	  m_index(index),
	  m_octaveShift(octaveShift),
	  m_noteShift(noteShift),
	  m_fineTuning(fineTuning),
	  m_commentsFlag(commentsFlag)
{
}

std::string Mikrotik::getTimeAsText(const double time)
{
	std::stringstream out;
	out << std::setfill('0') << std::setw(2) << ((static_cast<int>(time) / (1000 * 60 * 60)) % 24) << ":";
	out << std::setfill('0') << std::setw(2) << ((static_cast<int>(time) / (1000 * 60)) % 60) << ":";
	out << std::setfill('0') << std::setw(2) << ((static_cast<int>(time) / 1000) % 60) << ":";
	out << std::setfill('0') << std::setw(3) << ((static_cast<int>(time) % 1000));
	return out.str();
}

std::string Mikrotik::getTrackTimeLength(const uint8_t channel)
{
	std::stringstream out;
	out << getTimeAsText(mtrk_get_duration_ms(m_track, m_ppqn, m_bpm));
	out << " HH:MM:SS:MS";
	return out.str();
}

std::string Mikrotik::getNotesCount(const uint8_t channel)
{
	uint64_t count = 0;
	std::stringstream out;
	midi_cmd_t cmd = {.status = MIDI_STATUS_NOTE_ON, .subCmd = channel};
	uint8_t message_meta = 0;
	uint32_t eventIndex = mtrk_find_event_index(m_track, 0, cmd, message_meta);
	while (eventIndex != -1)
	{
		count++;
		eventIndex = mtrk_find_event_index(m_track, eventIndex + 1, cmd, message_meta);
	}
	out << count;
	return out.str();
}

std::string Mikrotik::getScriptHeader(const uint8_t channel)
{
	std::stringstream outputBuffer;
	outputBuffer << "#----------------File Description-----------------#\n";
	outputBuffer << "# This file generated by Midi To Mikrotik Converter\n";
	outputBuffer << "# Visit app repo: https://github.com/altucor/midi_to_mikrotik_converter\n";
	// outputBuffer << "# Original midi file name/path: " << m_filePath << "\n";
	outputBuffer << "# Track BPM: " << std::to_string(m_bpm) << "\n";
	outputBuffer << "# MIDI Channel: " << std::to_string(channel) << "\n";
	outputBuffer << "# Number of notes: " << getNotesCount(channel) << "\n";
	outputBuffer << "# Track length: " << getTrackTimeLength(channel) << "\n";
	// outputBuffer << "# Track name: " << m_track.getName() << "\n";
	// outputBuffer << "# Instrument name: " << m_track.getInstrumentName() << "\n";
	// outputBuffer << "# Track text: " << chunk.mtrkChunkHandler.getTrackText() << "\n";
	// outputBuffer << "# Track copyright: " << chunk.mtrkChunkHandler.getCopyright() << "\n";
	// outputBuffer << "# Vocals: " << chunk.mtrkChunkHandler.getInstrumentName() << "\n";
	// outputBuffer << "# Text marker: " << chunk.mtrkChunkHandler.getTextMarker() << "\n";
	// outputBuffer << "# Cue Point: " << chunk.mtrkChunkHandler.getCuePoint() << "\n";
	outputBuffer << "#-------------------------------------------------#\n\n";
	return outputBuffer.str();
}

std::string Mikrotik::getDelayLine(const float delayMs)
{
	std::stringstream out;
	if (delayMs != 0.0f)
		out << ":delay " << delayMs << "ms;\n";
	m_processedTime += delayMs;
	return out.str();
}

std::string Mikrotik::getBeepLine(midi_note_t note, const float duration)
{
	/*
	 * :beep frequency=440 length=1000ms;
	 * :delay 1000ms;
	 */

	std::stringstream out;
	note.pitch += (MIDI_NOTES_IN_OCTAVE * m_octaveShift) + m_noteShift;
	const float freq = midi_note_freq(&note) + m_fineTuning;
	if (freq == 0.0f)
	{
		BOOST_LOG_TRIVIAL(warning) << "Found note with zero frequency, ignoring it:";
		// note.log();
	}
	if (duration == 0.0f)
	{
		BOOST_LOG_TRIVIAL(warning)
			<< "Found overlayed note ignoring it:";
		// note.log();
		return out.str();
	}

	out << ":beep frequency=" << freq;
	out << " length=" << duration << "ms;";
	if (m_commentsFlag)
	{
		out << " # " << midi_note_name(&note) + std::to_string(m_fineTuning);
		out << " @ " << getTimeAsText(m_processedTime);
	}
	out << "\n";
	m_processedTime += duration;
	return out.str();
}

// std::string Mikrotik::buildNote(midi_event_smf_t *event)
// {

// 	/*
// 	outputBuffer << ":beep frequency=" << noteOn.getFrequencyHz();
// 	outputBuffer << " length=" << noteOn.getDurationPulses() << "ms;";
// 	if(m_commentsFlag)
// 		outputBuffer << " # " << noteOn.getSymbolicNote();
// 	outputBuffer << "\n:delay " <<
// 		(noteOff.getDurationPulses() + noteOn.getDurationPulses()) << "ms;\n\n";
// 	*/

// 	// note.log();
// 	std::stringstream out;

// 	if (event->message.status == MIDI_STATUS_NOTE_OFF)
// 	{
// 		out << getBeepLine(note);
// 	}
// 	double delay = durationToMs(note.getDelay(), m_track.getPulsesPerSecond());
// 	if (delay != 0.0)
// 	{
// 		out << getDelayLine(durationToMs(note.getDelay(), m_track.getPulsesPerSecond()));
// 		out << "\n";
// 	}
// 	return out.str();
// }

int Mikrotik::buildScriptForChannel(std::string &fileName, const uint8_t channel)
{
	m_processedTime = 0.0;
	std::string outFileName(fileName);
	outFileName += std::string("_");
	// outFileName += m_track.getName();
	outFileName += std::string("_");
	outFileName += std::to_string(m_index);
	outFileName += std::string("_");
	outFileName += std::to_string(channel);
	outFileName += std::string(".txt");

	std::stringstream outputBuffer;
	outputBuffer << getScriptHeader(channel);

	uint64_t foundNoteEventsCount = 0;
	float pps = pulses_per_second(m_ppqn, m_bpm);

	uint32_t eventsCount = mtrk_get_events_count(m_track);
	for (uint32_t i = 0; i < eventsCount; i++)
	{
		midi_event_smf_t *event = mtrk_get_event(m_track, i);
		if (event->message.subCmd != channel)
		{
			continue;
		}
		if (event->predelay.val != 0)
		{
			outputBuffer << getDelayLine(duration_to_ms(event->predelay.val, pps));
		}
		if (event->message.status == MIDI_STATUS_NOTE_ON)
		{
			int32_t noteOffIndex = mtrk_find_corresponding_note_off(m_track, i, *event);
			if (noteOffIndex == -1)
			{
				BOOST_LOG_TRIVIAL(info) << "Cannot find corresponding noteOff event for noteOn at index: " << std::to_string(i);
				continue;
			}

			float noteDuration = 0.0f;
			for (uint32_t j = i; j < noteOffIndex - i; j++)
			{
				midi_event_smf_t *tempEvent = mtrk_get_event(m_track, j);
				noteDuration += duration_to_ms(tempEvent->predelay.val, pps);
			}
			getBeepLine(event->event.note, noteDuration);
			foundNoteEventsCount++;
		}
	}

	if (foundNoteEventsCount == 0)
	{
		return 0;
	}

	BOOST_LOG_TRIVIAL(info)
		<< "Mikrotik buildScript started for track: "
		<< m_index << " channel: " << (uint32_t)channel;

	std::ofstream outputFile;
	outputFile.open(outFileName);
	if (!outputFile.is_open())
	{
		BOOST_LOG_TRIVIAL(info)
			<< "Mikrotik buildScript failed cannot create output file: "
			<< outFileName;
		return -1;
	}
	outputFile << outputBuffer.str();
	outputFile.close();
	BOOST_LOG_TRIVIAL(info) << "Mikrotik buildScript generated file: " << outFileName;
	return 0;
}

int Mikrotik::buildScript(std::string &fileName)
{
	// if (m_track.getEvents().size() == 0)
	// {
	// 	BOOST_LOG_TRIVIAL(info) << "Cannot find any events in track, skipping";
	// 	return 0;
	// }

	int ret = 0;
	for (uint8_t channel = 0; channel < 16; channel++)
	{
		ret = buildScriptForChannel(fileName, channel);
		if (ret != 0)
		{
			BOOST_LOG_TRIVIAL(info)
				<< "Mikrotik buildScript failed on channel: " << channel;
		}
	}
	return ret;
}
